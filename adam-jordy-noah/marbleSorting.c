#pragma config(Sensor, in1,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, in2,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in3,    lightSensorOne, sensorReflection)
#pragma config(Sensor, dgtl1,  limitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  bumpSwitch,     sensorTouch)
#pragma config(Sensor, dgtl3,  quad,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl12, green,          sensorLEDtoVCC)
#pragma config(Motor,  port1,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           metalClearGate, tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           dispenseWheel, tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           forkRight,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           forkLeft,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           lightGate,     tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Group members: Jordy Mazza, Noah Canel, Adam Kalman
@author: Adam Kalman
Pseudocode:
Release one marble at a time
Use first light sensor to determine if marble is the black, rubber marble
If not black marble, sort to one area, where it will be deposited into proper bin
Bin to be placed into determined by light sensor value which will be compared to an array to determine which marble it is
If at inital sorting area, and it is a black marble, then send to ramp where it is dropped at an angle
Based on bounce of marble, it falls into apporpriate bin.
*/


void runMotor(tMotor myMotor, int speed, int time){
	/*
	Function to run a motor.
	Takes a motor, a integer of speed, and integer of time as parameters
	*/
	int currentSpeed=motor[myMotor];
	motor[myMotor]=speed;
	wait1Msec(time);
	motor[myMotor]=currentSpeed;

}
int classifyMarble(int senseVal){
	if (senseVal<100){
		return 0;
	}
	if (senseVal>200 && senseVal<815){
		return 2;
	}
	if (senseVal>816){
		return 1;
	}
	else {
		return 3;
	}
}
/*
	int marbleLightValues[3]; //You should test your own values. These numbers worked for OUR machine, but it might not for yours
	marbleLightValues[0]=36; //Clear marble
	marbleLightValues[1]=400; //Metal 410 -840
	marbleLightValues[2]=650; //Black 560 360 -800
	for (int k=0; k<=2; k++){
		if (senseVal>marbleLightValues[k]-75 && senseVal<marbleLightValues[k]+75){
			return k;
		}
	}

	return 3; //No match

}
*/
task main()
{
	int fRightToLeft=10;
	int fRightToRight=-50;
	int fLeftToLeft=30;
	int fLeftToRight=-20;
	int fMetal=-20;
	int fClear=20;
	int gateOpen=63;
	int gateClose=-30;
	int marblesRemaining=16; //How many are there?
	int marbleTest;
	motor[flashlight]=127; //This should always be on
	//wait1Msec(1000); //Make sure it came on before using sensor values
	while (marblesRemaining>0){
		motor[lightGate]=gateClose;
		motor[dispenseWheel]=20;
		wait1Msec(750);
		motor[dispenseWheel]=0;
		wait1Msec(2000);
		int x=classifyMarble(SensorValue[lightSensorOne]);
		if(x==2){ //If it is a black marble, direct right
			motor[forkRight]=fRightToLeft; //Test values later
			motor[forkLeft]=fLeftToLeft; //Test values later
			motor[lightGate]=gateOpen;
			//Marble is now going down the ramp to bounce into container. Job done.
		}
		/*
		else if(x==3){
			//Hopefully this doesn't happen. If it does, we are in trouble
			break;
		}
		*/
		else if(x==1){ //Then, must be metal
			motor[forkRight]=fRightToRight;
			motor[forkLeft]=fLeftToRight;
			motor[metalClearGate]=fMetal; //Figure out all values for these
			motor[lightGate]=gateOpen;
			//Marble is directed towards left side of fork, then to side of fork designated for metal marbles, and ramp leads into container. Job done.
		}
		else if(x==0 || x==3){ //Then, must be clear
			motor[forkRight]=fRightToRight;
			motor[forkLeft]=fLeftToRight;
			motor[metalClearGate]=fClear; //Figure out all values for these.
			motor[lightGate]=gateOpen;
			//Marble is directed towards left side of fork, then to side of fork designated for clear marbles, and ramp leads into container. Job done.
		}
		wait1Msec(2000);

	}
}

#pragma config(Sensor, in1,    lineFollower,   sensorLineFollower)
#pragma config(Sensor, in2,    potentiometer,  sensorPotentiometer)
#pragma config(Sensor, in3,    lightSensorOne, sensorReflection)
#pragma config(Sensor, dgtl1,  limitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl2,  bumpSwitch,     sensorTouch)
#pragma config(Sensor, dgtl3,  quad,           sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  sonar,          sensorSONAR_inch)
#pragma config(Sensor, dgtl12, green,          sensorLEDtoVCC)
#pragma config(Motor,  port1,           flashlight,    tmotorVexFlashlight, openLoop, reversed)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           metalClearGate, tmotorServoStandard, openLoop)
#pragma config(Motor,  port6,           lightGate,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port7,           forkRight,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port8,           forkLeft,      tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           firstGate,     tmotorServoStandard, openLoop)
#pragma config(Motor,  port10,          dispenseWheel, tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Group members: Jordy Mazza, Noah Canel, Adam Kalman
Pseudocode:
Release one marble at a time
Use first light sensor to determine if marble is the black, rubber marble
If not black marble, sort to one area, where it will be deposited into proper bin
Bin to be placed into determined by light sensor value which will be compared to an array to determine which marble it is
If at inital sorting area, and it is a black marble, then send to ramp where it is dropped at an angle
Based on bounce of marble, it falls into apporpriate bin.
*/


void runMotor(tMotor myMotor, int speed, int time){
	/*
	Function to run a motor.
	Takes a motor, a integer of speed, and integer of time as parameters
	*/
	int currentSpeed=motor[myMotor];
	motor[myMotor]=speed;
	wait1Msec(time);
	motor[myMotor]=currentSpeed;

}
int classifyMarble(int senseVal){
	int marbleLightValues[3]; //You should test your own values. These numbers worked for OUR machine, but it might not for yours
	marbleLightValues[0]=38; //Clear marble
	marbleLightValues[1]=775; //Metal
	marbleLightValues[2]=978; //Black
	for (int k=0; k<=2; k++){
		if (senseVal>marbleLightValues[k]-100 && senseVal<marbleLightValues[k]+100){
			return k;
		}
	}

	return 3; //No match
}

task main()
{
	int marblesRemaining=16; //How many are there?
	int marbleTest;
	motor[flashlight]=127; //This should always be on
	wait1Msec(1000); //Make sure it came on before using sensor values
	while (marblesRemaining>0){
		motor[lightGate]=0;
		runMotor(dispenseWheel, 127, 1000);  //not sure speed and time, this will have to be tested and changed
		if(classifyMarble(SensorValue[lightSensorOne]==2)){ //If it is a black marble, direct right
			motor[forkRight]=63; //Test values later
			motor[forkLeft]=63; //Test values later
			motor[lightGate]=-63;
			//Marble is now going down the ramp to bounce into container. Job done.
		}
		else if(classifyMarble(SensorValue[lightSensorOne]==3)){
			//Hopefully this doesn't happen. If it does, we are in trouble
			break;
		}
		else if(classifyMarble(SensorValue[lightSensorOne]==1)){ //Then, must be metal
			motor[forkRight]=-63;
			motor[forkLeft]=-63;
			motor[metalClearGate]=-63; //Figure out all values for these
			motor[lightGate]=-63;
			//Marble is directed towards left side of fork, then to side of fork designated for metal marbles, and ramp leads into container. Job done.
		}
		else if(classifyMarble(SensorValue[lightSensorOne]==0)){ //Then, must be clear
			motor[forkRight]=-63;
			motor[forkLeft]=-63;
			motor[metalClearGate]=63; //Figure out all values for these.
			motor[lightGate]=-63;
			//Marble is directed towards left side of fork, then to side of fork designated for clear marbles, and ramp leads into container. Job done.
		}

	}
}
